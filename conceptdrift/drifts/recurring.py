import copy
import datetime

from pm4py.objects.process_tree import semantics

from conceptdrift.source.evolution import evolve_tree_randomly_gs
from conceptdrift.source.event_log_controller import generate_two_parts_of_event_log, combine_two_logs, \
    generate_several_parts_of_event_log, add_duration_to_log, get_timestamp_log
from conceptdrift.source.process_tree_controller import generate_specific_trees, visualise_tree
from pm4py.objects.log.exporter.xes import exporter as xes_exporter


def recurring_drift(num_traces=1000, start_point=0.0, end_point=1.0, num_of_seasonal_changes=3, pro_first_version=0.5, model_one=None, model_two=None, change_proportion=0.4):
    """ Generation of an event log with a recurring drift

    :param num_traces: number of traces in the event log
    :param start_point: start change point of the drift as a proportion of the total number of traces
    :param end_point: end change point of the drift as a proportion of the total number of traces
    :param num_of_seasonal_changes: the number of changes of the model versions in the event log
    :param pro_first_version: proportion of the traces generated by the initial model version during the drift
    :param model_one: initial version of the process tree
    :param model_two: evolved version of the process tree
    :param change_proportion: proportion of total number of activities to be changed by random evolution (model_two must be None if random evolution is targeted)
    :return: event log with recurring drift
    """
    deleted_acs = []
    added_acs = []
    moved_acs = []
    if model_one is None:
        ver_one = generate_specific_trees('middle')
        ver_copy = copy.deepcopy(ver_one)
        ver_two, deleted_acs, added_acs, moved_acs = evolve_tree_randomly_gs(ver_copy, change_proportion)
    elif model_one is not None and model_two is None:
        ver_one = model_one
        ver_copy = copy.deepcopy(ver_one)
        ver_two, deleted_acs, added_acs, moved_acs = evolve_tree_randomly_gs(ver_copy, change_proportion)
    else:
        ver_one = model_one
        ver_two = model_two
    nu_traces_log_one = int(
        round((num_traces * start_point) + (num_traces * ((end_point - start_point) * pro_first_version)) + 0.0001))
    nu_traces_log_two = num_traces - nu_traces_log_one
    log_one = semantics.generate_log(ver_one, nu_traces_log_one)
    log_two = semantics.generate_log(ver_two, nu_traces_log_two)
    if start_point == 0:
        nu_occur_one = int(round((num_of_seasonal_changes + 1.1) / 2))
        nu_occur_two = (num_of_seasonal_changes + 1) - nu_occur_one
    else:
        nu_occur_two = int(round((num_of_seasonal_changes + 1.1) / 2))
        nu_occur_one = (num_of_seasonal_changes + 1) - nu_occur_two
    nu_traces_start = int(round(num_traces * start_point + 0.0001))
    nu_traces_sec_drift = int(
        round((((num_traces * end_point) - (num_traces * start_point)) * (1 - pro_first_version)) + 0.0001))
    event_log, log_drift = generate_two_parts_of_event_log(log_one, nu_traces_start)
    sec_drift_log, log_end = generate_two_parts_of_event_log(log_two, nu_traces_sec_drift)
    parts_log_one = generate_several_parts_of_event_log(log_drift, nu_occur_one)
    parts_log_two = generate_several_parts_of_event_log(sec_drift_log, nu_occur_two)
    if start_point == 0:
        event_log = combine_two_logs(event_log, parts_log_one[0])
        event_log = combine_two_logs(event_log, parts_log_two[0])
        i = 1
        while i < nu_occur_two:
            event_log = combine_two_logs(event_log, parts_log_one[i])
            event_log = combine_two_logs(event_log, parts_log_two[i])
            i = i + 1
        if nu_occur_two != nu_occur_one:
            event_log = combine_two_logs(event_log, parts_log_one[nu_occur_one - 1])
        if end_point != 1:
            event_log = combine_two_logs(event_log, log_end)
    else:
        event_log = combine_two_logs(event_log, parts_log_two[0])
        event_log = combine_two_logs(event_log, parts_log_one[0])
        i = 1
        while i < nu_occur_one:
            event_log = combine_two_logs(event_log, parts_log_two[i])
            event_log = combine_two_logs(event_log, parts_log_one[i])
            i = i + 1
        if nu_occur_two != nu_occur_one:
            event_log = combine_two_logs(event_log, parts_log_two[nu_occur_two - 1])
        if end_point != 1:
            event_log = combine_two_logs(event_log, log_end)
    date = datetime.datetime.strptime('20/8/3 8:0:0', '%y/%d/%m %H:%M:%S')
    add_duration_to_log(event_log, date, 1, 14000)
    start_drift = get_timestamp_log(event_log, num_traces, start_point)
    end_drift = get_timestamp_log(event_log, num_traces, end_point)
    if model_two is None:
        data = "drift perspective: control-flow; drift type: recurring; drift specific information: " + str(num_of_seasonal_changes) + " seasonal changes; drift start timestamp: " + str(start_drift) + " (" + str(start_point) + "); drift end timestamp: " + str(end_drift) + " (" + str(end_point) + "); activities added: " + str(added_acs) + "; activities deleted: " + str(deleted_acs) + "; activities moved: " + str(moved_acs)
    else:
        data = "drift perspective: control-flow; drift type: recurring; drift specific information: " + str(num_of_seasonal_changes) + " seasonal changes; drift start timestamp: " + str(start_drift) + " (" + str(start_point) + "); drift end timestamp: " + str(end_drift) + " (" + str(end_point) + ")"
    event_log.attributes['drift info'] = data
    return event_log

"---TESTS---"
# ve_one = generate_specific_trees('simple')
# ve_two = generate_specific_trees('simple')
# log = recurring_drift(1000, 4, 0.5, 0.2, 0.8, ve_one, ve_two)
# log = recurring_drift()
# xes_exporter.apply(log, "event_log.xes")
